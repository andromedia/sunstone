{
  "name": "Sunstone",
  "tagline": "Simple library which helps to control virtual machines in cloud environments. It's aimed mainly to testing WildFly application server.",
  "body": "> Name: [Sunstone](https://en.wikipedia.org/wiki/Sunstone_\\(medieval\\))\r\n> is a crystal that was supposedly used by Vikings to navigate in cloudy weather.\r\n\r\n[![Build Status](https://travis-ci.org/wildfly-extras/sunstone.svg?branch=master)](https://travis-ci.org/wildfly-extras/sunstone)\r\n\r\n## Motivation\r\n\r\n### Why?\r\n\r\n*Why yet another library?*  \r\n*Because clouds exist. And they are many! Moreover, everybody loves new libraries, of course.*\r\n\r\nThe library is here to simplify test development for new clouds. One set of test can be reused for different kind of providers.\r\n\r\n### What?\r\n\r\n*What does it bring to me?*  \r\n*One view to rule them all.*\r\n\r\n* single Java API for all supported cloud providers\r\n* possibility to control WildFly nodes with [Creaper](https://github.com/wildfly-extras/creaper)\r\n* Arquillian test framework support\r\n\r\n### How?\r\n\r\n*It's so cool. Now, show me the code!*\r\n\r\nAdd the maven dependency to your project:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.wildfly.extras.sunstone</groupId>\r\n    <artifactId>sunstone-core</artifactId>\r\n    <version>${version.org.wildfly.extras.sunstone}</version>\r\n</dependency>\r\n```\r\nDefine cloud configuration in `my-cloud.properties` property file:\r\n\r\n```properties\r\n# Cloud provider - an entrypoint to given cloud\r\ncloud.provider.my-provider.type=docker\r\ncloud.provider.my-provider.docker.endpoint=http://dockerhost0.acme.com:2375/\r\n\r\n# Node - a single virtual machine in the cloud \r\nnode.wildfly-node.docker.image=jboss/wildfly:10.0.0.Final\r\nnode.wildfly-node.docker.waitForPorts=8080,9990\r\nnode.wildfly-node.docker.waitForPorts.timeoutSec=30\r\n```\r\n\r\nThen use your favorite Java 8 to do the stuff in the cloud:\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.URL;\r\n\r\nimport org.wildfly.extras.sunstone.api.CloudProperties;\r\nimport org.wildfly.extras.sunstone.api.CloudProvider;\r\nimport org.wildfly.extras.sunstone.api.Node;\r\n\r\nimport com.squareup.okhttp.OkHttpClient;\r\nimport com.squareup.okhttp.Request;\r\n\r\n/**\r\n * Sunstone quick-start. It creates cloud provider, starts a single node in it and\r\n * makes HTTP request (port 8080) against the node.\r\n */\r\npublic class App {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tCloudProperties.getInstance().load(\"my-cloud.properties\");\r\n\t\ttry (CloudProvider cloudProvider = CloudProvider.create(\"my-provider\")) {\r\n\t\t\ttry (Node node = cloudProvider.createNode(\"wildfly-node\")) {\r\n\t\t\t\tfinal URL url = new URL(\"http\", node.getPublicAddress(), 8080, \"\");\r\n\t\t\t\tfinal OkHttpClient client = new OkHttpClient();\r\n\t\t\t\tfinal Request nodeNameRequest = new Request.Builder().url(url).build();\r\n\t\t\t\tSystem.out.println(\"Response from \" + url);\r\n\t\t\t\tSystem.out.println(client.newCall(nodeNameRequest).execute().body().string());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Clouds support\r\n\r\nAvailable:\r\n* [Docker](https://github.com/wildfly-extras/sunstone/blob/master/docker-README.md#readme)\r\n* [Microsoft Azure](https://github.com/wildfly-extras/sunstone/blob/master/azure-README.md#readme) and, as a technical preview, [Microsoft Azure (ARM)](https://github.com/wildfly-extras/sunstone/blob/master/azure-arm-README.md#readme)\r\n* [Amazon EC2](https://github.com/wildfly-extras/sunstone/blob/master/ec2-README.md#readme)\r\n* [OpenStack](https://github.com/wildfly-extras/sunstone/blob/master/openstack-README.md#readme)\r\n* [Bare Metal](https://github.com/wildfly-extras/sunstone/blob/master/baremetal-README.md#readme) (not really a cloud provider per se, but useful anyway)\r\n\r\n## WildFly/EAP support\r\n\r\n* [WildFlyNode wrapper](https://github.com/wildfly-extras/sunstone/blob/master/wildfly-README.md#readme)\r\n* [Arquillian extension](https://github.com/wildfly-extras/sunstone/blob/master/arquillian-README.md#readme)\r\n\r\n## Logging\r\n\r\nSLF4J is used as a logging facade, so you have to have the appropriate adapter on the classpath. If you use Logback,\r\nyou don't have to do anything. For other loggers, see [the SLF4J manual](http://www.slf4j.org/manual.html).\r\n\r\nThe loggers are called `sunstone.*`, short and clear. (For example: `sunstone.core`, `sunstone.core.ssh` etc.)\r\n\r\n## Abstraction levels\r\n\r\nThe library is build around 2 main interfaces:\r\n* `CloudProvider` - represents an entry point to given cloud and is able to control Nodes in it\r\n* `Node` - virtual machines (or containers) in the given cloud\r\n\r\n### Cloud provider\r\n\r\nCloud providers are controllers of (or entrypoints to) the given cloud. They are configured through properties prefixed with\r\n**`cloud.provider.[name].`**\r\n\r\nExample:\r\n\r\n```properties\r\ncloud.provider.provider0.type=docker\r\ncloud.provider.provider0.docker.endpoint=http://127.0.0.1:2375/\r\n```\r\n\r\nA new cloud provider is created by using a factory class. \r\nThe `CloudProvider` interface extends `AutoCloseable` so it's a good practice to use it in the try-with-resource block.\r\n\r\n```java\r\nimport org.wildfly.extras.sunstone.api.CloudProvider;\r\n\r\ntry (CloudProvider cloudProvider = CloudProvider.create(\"provider0\")) {\r\n    // work with the cloudProvider here\r\n}\r\n```\r\n\r\nThe most important feature of cloud providers is their ability to control nodes (virtual machines) in the cloud.\r\n\r\n```java\r\nimport org.wildfly.extras.sunstone.api.Node;\r\n\r\n\r\n// create nodes\r\nNode nodeA = cloudProvider.createNode(\"myNodeName\");\r\nNode nodeB = cloudProvider.createNode(\"anotherNodeName\");\r\n\r\n// or list nodes\r\nList<Node> allNodes = cloudProvider.getNodes();\r\n```\r\n\r\nThere is one general configuration option for cloud providers - **`cloud.provider.[name].type`** which selects cloud provider implementation.\r\nFor more configuration options consult documentation of specific cloud implementation. \r\n\r\n\r\n### Node\r\n\r\nThe `Node` interface represents a single virtual machine in the cloud. Nodes are configured through properties prefixed with\r\n**`node.[name].`**. For instance\r\n\r\n```properties\r\nnode.node0.docker.image=jboss/wildfly:10.0.0.Final\r\nnode.node0.docker.waitForPorts=8080\r\nnode.node0.docker.waitForPorts.timeoutSec=30\r\n```\r\n\r\nNode creation is controlled by cloud providers. \r\nThe `Node` interface also extends `AutoCloseable` so it's again a good practice to use it in the try-with-resource block.\r\n\r\n```java\r\ntry (Node node = cloudProvider.createNode(\"node0\")) {\r\n    // work with the node here\r\n}\r\n```\r\n\r\nThe Node interface provides set of methods to work with it. It supports for instance:\r\n\r\n* executing commands on the node\r\n* copying files from/to node\r\n* controlling running state of the node (`start`, `stop`, `kill`)\r\n* retrieving the node address\r\n* checking if a port is open on the node\r\n\r\nList of general `Node` properties:\r\n\r\n| Property name    | Description                                                                              | Default value     |\r\n|:-----------------|:-----------------------------------------------------------------------------------------|:------------------|\r\n| waitForPorts     | What ports (comma separated list) to wait for. SSH port is recommended, since you'll likely want to run some commands through ssh on the Node. | [None. Optional.] |\r\n| waitForPorts.timeoutSec | How long to wait for ports to open after the instance is started (in seconds).    | 60                |\r\n| bootScript       | Allows you to specify a script that is to be run on boot.                                | [None. Optional.] |\r\n| bootScript.file  | As `bootScript`, but allows you to specify a path to a file that contains the script. Only one of `bootScript` and `bootScript.file` can be specified at a time. | [None. Optional.] |\r\n| bootScript.withSudo | Flag (`true`/`false`) which controls if the boot script runs with sudo.               | `true`            |\r\n| bootScript.remotePath | Path on the Node, where the bootScript should be stored.                            | `\"/tmp/onBootScript.sh\"` |\r\n| bootScript.waitForPorts | What ports (comma separated list) to wait for **before** the executing `bootScript`. This property is not used if no `bootScript` (or `bootScript.file`) is provided. | [None. Optional.] |\r\n| bootScript.waitForPorts.timeoutSec | How long to wait for ports to open before the bootscript is executed (in seconds). | 60    |\r\n| start.timeoutSec | How long to wait for node start (in seconds).                                            | 300               |\r\n| stop.timeoutSec  | How long to wait for node stop (in seconds).                                             | 300               |\r\n| sudo.command     | Sudo command to be used for `ExecBuilder` executions when `withSudo()` is used.          | `sudo -S`         |\r\n\r\nThese properties can be overriden on cloud provider level by appending provider name prefix (e.g. `docker.bootScript`).\r\n\r\nConsult documentation of specific cloud implementation for Node configuration options. \r\n\r\n#### Node API example\r\n\r\nTar a folder on a Node and copy it to local filesystem:\r\n\r\n```java\r\nExecResult execResult = node.exec(\r\n\t\t\"tar\",\r\n\t\t\"-czvf\",\r\n\t\t\"/tmp/wildfly-logs.tgz\",\r\n\t\t\"/opt/jboss/wildfly/standalone/log\");\r\n\r\nif (execResult.getExitCode() == 0) {\r\n\tnode.copyFileFromNode(\"/tmp/wildfly-logs.tgz\", Paths.get(\"wildfly-logs.tgz\"));\r\n}\r\n```\r\n\r\n### NodeWrapper\r\n\r\nSpecial implementation of the `Node` interface is the `NodeWrapper` class. \r\n\r\nIt provides a convenient implementation of the Node interface that can be subclassed by developers wishing to adapt behavior or\r\nprovide additional functionality. This class implements the Wrapper or Decorator pattern. Methods default to calling through\r\nto the wrapped request object.\r\n\r\n## Configuration\r\n\r\nSingleton `CloudProperties` is used to hold library configuration. It allows to load properties from files on system path or classpath.\r\nIf a classpath resource `/sunstone.properties` exists, it is loaded by default.\r\n\r\n```java\r\nimport org.wildfly.extras.sunstone.api.CloudProperties;\r\n\r\nCloudProperties.getInstance().load(\"/org/jboss/cloud.properties\").load(\"/opt/sunstone/wildfly-nodes.properties\");\r\n\r\n// TODO work with sunstone \r\n\r\nCloudProperties.getInstance().reset();\r\n```\r\n\r\nProperties configured in `CloudProperties` can be overridden in several ways. Users can choose their preferred way.\r\n\r\n### Configuration templates\r\n\r\nYou can use existing object configuration as a template for new objects of the same type.\r\n\r\nUse property name **`[objectType].[objectName].template`** to reference the template.\r\n\r\n```properties\r\n# define a node\r\nnode.nodeA.docker.image=jboss/wildfly\r\nnode.nodeA.docker.waitForPorts=8080\r\nnode.nodeA.docker.waitForPorts.timeoutSec=30\r\n\r\n# use the nodeA configuration as a template for a new node\r\nnode.nodeB.template=nodeA\r\nnode.nodeB.docker.cmd=/opt/jboss/wildfly/bin/standalone.sh,-b,0.0.0.0\r\n\r\n# it's possible to use more template levels and override properties from template\r\nnode.nodeC.template=nodeB\r\nnode.nodeC.docker.waitForPorts=9990\r\n```\r\n\r\n### Single object properties\r\n\r\nProperties for a single object can also be provided in a property file which contains entries without `[objectType].[objectName].`\r\nprefix. This file is then referenced from `[objectType].[objectName].properties` entry.\r\n\r\nFor instance you can have a property file `/home/test/wildfly-node.properties` which contains:\r\n\r\n```properties\r\ndocker.image=jboss/wildfly\r\ndocker.waitForPorts=8080\r\ndocker.waitForPorts.timeoutSec=30\r\n```\r\n\r\nThen property file used in `CloudProperties` configuration could contain:\r\n\r\n```properties\r\n# reference external configuration file\r\nnode.node0.properties=/home/test/wildfly-node.properties\r\n\r\n# use external configuration and override some values\r\nnode.node1.properties=/home/test/wildfly-node.properties\r\nnode.node1.waitForPorts=9990\r\n```\r\n\r\n### Overriding properties\r\n\r\nWhen the library searches a configuration entry, it goes through following levels.\r\n\r\n1. lookup entry with given name in **System Properties**\r\n1. lookup entry with given name in **`CloudProperties`**\r\n1. lookup entry located in property file referenced through single object properties `[objectType].[objectName].properties`\r\n1. lookup entry located in the object template (go through the all levels from the beginning)\r\n\r\nOnce the entry is found it's used (i.e. following levels are skipped).\r\n\r\nFor instance if properties for your tests contains \r\n\r\n```properties\r\nnode.nodeA.docker.image=jboss/wildfly\r\nnode.nodeA.docker.waitForPorts=8080\r\nnode.nodeA.docker.waitForPorts.timeoutSec=30\r\n```\r\n\r\nthen you can use system property to quickly override some value:\r\n\r\n```bash\r\nmvn test \"-Dnode.nodeA.docker.image=jboss/wildfly:10.0.0.Final\"\r\n```\r\n\r\n### Property replacement\r\n\r\nYou can also use system-properties replacement directly in property values.\r\nThe system property name and default value are separated by a colon `:`. \r\n\r\nIt means you can refer system properties directly in property file:\r\n\r\n```properties\r\n# try to find the value in \"wildfly.image\" system property. If it doesn't exist, then use default value \"jboss/wildfly\"\r\nnode.nodeA.docker.image=${wildfly.image:jboss/wildfly}\r\n```\r\n\r\n### File paths\r\n\r\nSome properties are expected to contain file paths. This is typical e.g. for SSH private keys:\r\n\r\n```properties\r\nnode.nodeA.openstack.ssh.privateKeyFile=/home/me/.ssh/id_rsa\r\n```\r\n\r\nIn such cases, it is possible to load data also from classpath, using the `classpath:` prefix:\r\n\r\n```properties\r\nnode.nodeA.openstack.ssh.privateKeyFile=classpath:org/jboss/test/openstack/ssh-private-key.pem\r\n```\r\n\r\nThe classpath resource path must be absolute. It must _not_ begin with `/` (see the javadoc of `Class.getResource`\r\nand `ClassLoader.getResource` to see the difference). Note that these classpath resources are actually copied\r\nto the filesystem and the resulting temporary files are scheduled to be deleted at JVM exit.\r\nThis shouldn't be a concern typically.\r\n\r\n## License\r\n\r\n* [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}